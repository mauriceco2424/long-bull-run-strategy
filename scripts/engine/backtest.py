"""
Main Backtest Engine

This is the main entry point for backtest execution, generated by /build-engine.
It coordinates all components to run a complete backtest simulation.
"""

import os
import sys
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
import logging

# Handle both relative and absolute imports
try:
    from .core.strategy_interface import StrategyInterface
    from .core.portfolio_manager import PortfolioManager
    from .core.order_manager import OrderManager
    from .core.risk_manager import RiskManager
    from .core.filter_gate_manager import FilterGateManager
    from .data.data_fetcher import DataFetcher
    from .data.data_processor import DataProcessor
    from .execution.fill_simulator import FillSimulator
    from .execution.fee_calculator import FeeCalculator
    from .execution.timing_engine import TimingEngine
    from .optimization.reference_engine import ReferenceEngine
    from .utils.config_parser import ConfigParser
    from .utils.progress_tracker import ProgressTracker
    from .utils.validators import DataValidator
    from .utils.logging_config import setup_logging, QuietProgressTracker
    from .rsi_mean_reversion_strategy import RSIMeanReversionStrategy
except ImportError:
    # Absolute imports for direct execution
    from core.strategy_interface import StrategyInterface
    from core.portfolio_manager import PortfolioManager
    from core.order_manager import OrderManager
    from core.risk_manager import RiskManager
    from core.filter_gate_manager import FilterGateManager
    from data.data_fetcher import DataFetcher
    from data.data_processor import DataProcessor
    from execution.fill_simulator import FillSimulator
    from execution.fee_calculator import FeeCalculator
    from execution.timing_engine import TimingEngine
    from optimization.reference_engine import ReferenceEngine
    from utils.config_parser import ConfigParser
    from utils.progress_tracker import ProgressTracker
    from utils.validators import DataValidator
    from utils.logging_config import setup_logging, QuietProgressTracker
    from rsi_mean_reversion_strategy import RSIMeanReversionStrategy


class BacktestEngine:
    """
    Main backtest execution engine.
    
    Orchestrates all components to run a complete backtest simulation with
    realistic timing, fees, slippage, and risk management.
    """
    
    def __init__(self, config_path: str = "parameter_config.md"):
        """
        Initialize backtest engine with configuration.
        
        Args:
            config_path: Path to parameter configuration file
        """
        self.logger = setup_logging(__name__)
        self.config_parser = ConfigParser()
        self.config = self.config_parser.parse_config(config_path)
        
        # Initialize components
        self.data_fetcher = DataFetcher(self.config)
        self.data_processor = DataProcessor(self.config)
        self.portfolio_manager = PortfolioManager(self.config)
        self.order_manager = OrderManager(self.config)
        self.risk_manager = RiskManager(self.config)
        self.fill_simulator = FillSimulator(self.config)
        self.fee_calculator = FeeCalculator(self.config)
        self.timing_engine = TimingEngine(self.config)
        self.progress_tracker = QuietProgressTracker(self.logger)
        self.data_validator = DataValidator()
        
        # Optimization components (enabled automatically for speed)
        self.filter_gate_manager = FilterGateManager()
        self.reference_engine = ReferenceEngine()
        
        # Register common filters for universal optimization
        self.filter_gate_manager.register_common_filters()
        
        # Initialize strategy (generated by /build-engine)
        # Using RSI Mean Reversion test strategy
        strategy_config = self.config.get('strategy_parameters', {})
        strategy_config['symbols'] = self.config.get('universe', {}).get('symbols', ['BTCUSDT', 'ETHUSDT', 'ADAUSDT'])
        self.strategy = RSIMeanReversionStrategy(strategy_config)
        
        # Runtime state
        self.current_time = None
        self.ohlcv_data = {}
        self.features_data = {}
        self.backtest_results = {
            'trades': [],
            'events': [],
            'daily_series': [],
            'metadata': {}
        }
    
    def run(self, run_id: str) -> Dict[str, Any]:
        """
        Execute the complete backtest.
        
        Args:
            run_id: Unique identifier for this backtest run
            
        Returns:
            Dictionary containing backtest results and metadata
        """
        try:
            # SILENT START - no initial message
            
            # Phase 1: Data preparation
            self.progress_tracker.start_phase("Data Loading", 0.25)
            self._prepare_data()
            self.progress_tracker.complete_phase()
            
            # Phase 2: Signal generation and execution
            self.progress_tracker.start_phase("Backtest Execution", 0.65)
            self._run_backtest_loop()
            self.progress_tracker.complete_phase()
            
            # Phase 3: Results generation
            self.progress_tracker.start_phase("Results Generation", 0.10)
            results = self._generate_results(run_id)
            self.progress_tracker.complete_phase()
            
            # Show final success status
            self.progress_tracker.complete_operation(show_success=True)
            return results
            
        except Exception as e:
            # Always report failures
            self.progress_tracker.report_failure(str(e))
            raise
    
    def _prepare_data(self) -> None:
        """Fetch and process all required data."""
        # Fetch raw OHLCV data
        self.ohlcv_data = self.data_fetcher.fetch_historical_data(
            symbols=self.config['universe']['symbols'],
            start_date=self.config['backtest']['start_date'],
            end_date=self.config['backtest']['end_date'],
            timeframe=self.config['timeframe']
        )
        
        # Process and validate data
        self.ohlcv_data = self.data_processor.process_ohlcv_data(self.ohlcv_data)
        self.data_validator.validate_ohlcv_data(self.ohlcv_data)
        
        # Calculate features using the strategy's method
        # RSI strategy handles its own feature calculation with optimization
        self.features_data = self.strategy.calculate_features(
            self.ohlcv_data,
            list(self.ohlcv_data.values())[0].index[-1] if self.ohlcv_data else None
        )
        
        # Data prepared - silent
    
    def _run_backtest_loop(self) -> None:
        """Execute the main backtest simulation loop."""
        # Get all timestamps from the first symbol's data
        first_symbol = next(iter(self.ohlcv_data.keys()))
        timestamps = self.ohlcv_data[first_symbol].index
        
        # Get warmup periods (default to 50 for RSI)
        warmup_periods = getattr(self.strategy, 'min_bars_required', 50)
        start_idx = max(0, warmup_periods)
        
        total_bars = len(timestamps) - start_idx
        
        for i, timestamp in enumerate(timestamps[start_idx:], start_idx):
            self.current_time = timestamp
            progress = (i - start_idx) / total_bars
            self.progress_tracker.update_progress(progress)
            
            # Get current bar data for all symbols
            current_ohlcv = self._get_current_bar_data(timestamp)
            current_features = self._get_current_features_data(timestamp)
            
            # Update portfolio with current prices
            current_prices = {symbol: data['close'] for symbol, data in current_ohlcv.items()}
            self.portfolio_manager.update_prices(current_prices)
            
            # Process pending orders from previous bar
            if self.order_manager.has_pending_orders():
                filled_orders = self.order_manager.process_pending_orders(
                    current_ohlcv, self.fill_simulator, self.fee_calculator
                )
                for fill in filled_orders:
                    self.portfolio_manager.process_fill(fill)
                    self._record_trade(fill)
                    # Update strategy positions
                    self.strategy.update_positions([fill])
            
            # Generate new signals
            portfolio_state = self.portfolio_manager.get_state()
            raw_signals = self.strategy.generate_signals(
                self.current_time, 
                {sym: self.ohlcv_data[sym] for sym in self.ohlcv_data},  # Pass full dataframes
                self.features_data,
                portfolio_state
            )
            
            # Convert RSI strategy signals to expected format
            signals = []
            for signal in raw_signals:
                signals.append({
                    'symbol': signal.symbol,
                    'action': 'buy' if 'entry' in signal.signal_type.value.lower() else 'sell',
                    'timestamp': signal.timestamp,
                    'price': signal.price,
                    'metadata': signal.metadata
                })
            
            # Process signals through risk management
            validated_signals = self.risk_manager.validate_signals(
                signals, portfolio_state, current_prices
            )
            
            # Convert signals to orders
            for signal in validated_signals:
                order = self._create_order_from_signal(signal, current_prices)
                if order:
                    self.order_manager.add_order(order)
                    self._record_event('signal_generated', signal)
            
            # Record daily portfolio state
            self._record_daily_state(timestamp, portfolio_state)
            
            # Strategy can track its state internally
    
    def _get_current_bar_data(self, timestamp: pd.Timestamp) -> Dict[str, Dict[str, float]]:
        """Get OHLCV data for current timestamp."""
        current_data = {}
        for symbol, df in self.ohlcv_data.items():
            if timestamp in df.index:
                bar = df.loc[timestamp]
                current_data[symbol] = {
                    'open': bar['open'],
                    'high': bar['high'], 
                    'low': bar['low'],
                    'close': bar['close'],
                    'volume': bar['volume']
                }
        return current_data
    
    def _get_current_features_data(self, timestamp: pd.Timestamp) -> Dict[str, Dict[str, float]]:
        """Get features data for current timestamp."""
        if not self.features_data:
            return {}
        
        current_features = {}
        for symbol, df in self.features_data.items():
            if timestamp in df.index:
                current_features[symbol] = df.loc[timestamp].to_dict()
        return current_features
    
    def _create_order_from_signal(self, signal: Dict[str, Any], prices: Dict[str, float]) -> Optional[Dict[str, Any]]:
        """Convert a strategy signal into an order."""
        symbol = signal['symbol']
        if symbol not in prices:
            # Only log serious issues
            if not self.logger.isEnabledFor(logging.ERROR):
                pass  # Silent
            return None
        
        current_price = prices[symbol]
        
        # Calculate position size if not specified
        quantity = signal.get('quantity')
        if quantity is None:
            # Use strategy's position sizing (10% of equity for RSI strategy)
            portfolio_state = self.portfolio_manager.get_state()
            position_value = portfolio_state['total_equity'] * self.strategy.position_size_pct
            quantity = position_value / current_price
        
        if quantity == 0:
            return None
        
        order = {
            'symbol': symbol,
            'action': signal['action'],
            'quantity': quantity,
            'order_type': signal.get('order_type', 'market'),
            'limit_price': signal.get('limit_price'),
            'stop_loss': signal.get('stop_loss'),
            'take_profit': signal.get('take_profit'),
            'timestamp': self.current_time,
            'metadata': signal.get('metadata', {})
        }
        
        return order
    
    def _record_trade(self, fill: Dict[str, Any]) -> None:
        """Record a completed trade."""
        self.backtest_results['trades'].append(fill)
    
    def _record_event(self, event_type: str, data: Dict[str, Any]) -> None:
        """Record a backtest event."""
        event = {
            'timestamp': self.current_time,
            'type': event_type,
            'data': data
        }
        self.backtest_results['events'].append(event)
    
    def _record_daily_state(self, timestamp: pd.Timestamp, portfolio_state: Dict[str, Any]) -> None:
        """Record daily portfolio state."""
        daily_record = {
            'timestamp': timestamp,
            'equity': portfolio_state['total_equity'],
            'cash': portfolio_state['cash'],
            'positions_value': portfolio_state['positions_value'],
            'open_positions': len(portfolio_state['positions']),
            'daily_return': portfolio_state.get('daily_return', 0.0)
        }
        self.backtest_results['daily_series'].append(daily_record)
    
    def _generate_results(self, run_id: str) -> Dict[str, Any]:
        """Generate final backtest results."""
        # Calculate performance metrics
        final_state = self.portfolio_manager.get_state()
        
        results = {
            'run_id': run_id,
            'config': self.config,
            'start_time': self.config['backtest']['start_date'],
            'end_time': self.config['backtest']['end_date'],
            'final_equity': final_state['total_equity'],
            'total_trades': len(self.backtest_results['trades']),
            'trades': self.backtest_results['trades'],
            'events': self.backtest_results['events'],
            'daily_series': self.backtest_results['daily_series'],
            'portfolio_final_state': final_state,
            'metadata': {
                'engine_version': '1.0.0',
                'execution_time': datetime.now().isoformat(),
                'symbols_traded': list(self.ohlcv_data.keys())
            }
        }
        
        return results
    
    # Remove custom logging setup - use centralized setup_logging


if __name__ == "__main__":
    """Direct execution entry point for testing."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Run RSI Mean Reversion Backtest')
    parser.add_argument('config_path', nargs='?', default='parameter_config.md',
                        help='Path to configuration file')
    parser.add_argument('--test-mode', action='store_true',
                        help='Enable test mode')
    parser.add_argument('--validate-accounting', action='store_true',
                        help='Enable accounting validation')
    
    args = parser.parse_args()
    
    # Determine config path - check current directory and parent directories
    config_path = args.config_path
    if not os.path.exists(config_path):
        # Try parent directory paths
        possible_paths = [
            os.path.join('..', '..', args.config_path),
            os.path.join('..', args.config_path),
            args.config_path
        ]
        for path in possible_paths:
            if os.path.exists(path):
                config_path = path
                break
        else:
            print(f"Error: Configuration file not found: {args.config_path}")
            sys.exit(1)
    
    print(f"Using configuration: {config_path}")
    engine = BacktestEngine(config_path)
    run_id = f"test_run_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    results = engine.run(run_id)
    print(f"Backtest completed: ${results['final_equity']:,.2f}")